# -*- coding: utf-8 -*-
"""guestures_classification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NieMXyBmkjt8MJN3SiNxVySEVq8foy1U
"""

import numpy as np
import matplotlib.pyplot as plt

from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.neural_network import MLPClassifier
from sklearn.metrics import ConfusionMatrixDisplay, classification_report
from sklearn.metrics import confusion_matrix
from sklearn import preprocessing
import pickle 
import seaborn as sb

RANDOM_SEED = 22340

filtered_dataset = np.loadtxt('filtered_data.txt', dtype=int)

import pandas as pd

df = pd.DataFrame(filtered_dataset)
cor = df.corr()
  
# plotting correlation heatmap
dataplot = sb.heatmap(cor, cmap="YlGnBu", annot=True)
  
# displaying heatmap
plt.show()

def fit_tree_classifier(X, y, **decisiontree_kwargs):
  clf = DecisionTreeClassifier(random_state=RANDOM_SEED)
  clf.fit(X,y)
  return clf


def fit_knn_classifier(X, y, **knn_kwargs):
  clf = KNeighborsClassifier()
  clf.fit(X,y)
  return clf

def fit_mlp_classifier(X,y, **mlp_kwargs):
  clf = MLPClassifier(solver='lbfgs', alpha=1e-5, random_state=1,**mlp_kwargs)
  clf.fit(X,y)
  return clf


def evaluate_classification(y_true, y_predicted):
    cm = confusion_matrix(y_true, y_predicted)
    report = classification_report(y_true, y_predicted)
    print(report)

    fig, ax = plt.subplots(figsize=(15,15))
    disp = ConfusionMatrixDisplay(cm, display_labels = None)
    
    disp.plot(ax=ax)
    plt.show()

train_data, test_data = train_test_split(filtered_dataset, test_size=0.25, random_state=RANDOM_SEED)
X_train = train_data[:,:5]
Y_train = train_data[:,5]

X_test = test_data[:,:5]
Y_test = test_data[:,5]

tree = fit_tree_classifier(X_train, Y_train)
knn = fit_knn_classifier(X_train, Y_train)

tree_pred = tree.predict(X_test)
knn_pred = knn.predict(X_test)

evaluate_classification(Y_test, tree_pred)

evaluate_classification(Y_test, knn_pred)

scaler = preprocessing.StandardScaler().fit(X_train)
X_train_scaled = scaler.transform(X_train)
X_test_scaled = scaler.transform(X_test)

mlp = fit_mlp_classifier(X_train_scaled, Y_train,  hidden_layer_sizes = (10,)) 
mlp_pred = mlp.predict(X_test_scaled)

evaluate_classification(Y_test, mlp_pred)

knnPickle = open('knnpickle_file', 'wb') 
pickle.dump(knn, knnPickle)  
knnPickle.close()

loaded_model = pickle.load(open('knnpickle_file', 'rb'))
result = loaded_model.predict(X_test)

evaluate_classification(Y_test, result)

import time

dict_ = {2:"test2", 5:"test"}

X = np.array([121,224,190,229,941]).reshape(1,5)
result = int(loaded_model.predict(X) )

print(dict_[result])

dict = {1:"word1", 2:"word2", 3:"word3", 4:"word4"}
file = open('knnpickle_file', 'rb')
model = pickle.load(file)

while True:
  serial_in = [195,117,18,1178,146]
  data = np.array(serial_in).reshape(1,5)
  result = model.predict(data)
  word = None
  try:
    word = dict_[result]
  except:
    print("No matching word")